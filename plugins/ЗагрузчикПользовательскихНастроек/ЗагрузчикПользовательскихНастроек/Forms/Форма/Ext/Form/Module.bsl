&НаКлиенте
Перем КонтекстЯдра;

// { Plugin interface
&НаКлиенте
Функция ОписаниеПлагина(ВозможныеТипыПлагинов) Экспорт
	Возврат ОписаниеПлагинаНаСервере(ВозможныеТипыПлагинов);
КонецФункции

&НаСервере
Функция ОписаниеПлагинаНаСервере(ВозможныеТипыПлагинов)
	Возврат ЭтотОбъектНаСервере().ОписаниеПлагина(ВозможныеТипыПлагинов);
КонецФункции

&НаКлиенте
Процедура Инициализация(КонтекстЯдраПараметр) Экспорт
	КонтекстЯдра = КонтекстЯдраПараметр;
КонецПроцедуры

// } Plugin interface

// { API

// Загружает глобальноые переменные сохраняемого контекста из внешнего файла
// с именем user_settings.json. Формат файла должен быть следующего вида:
// {
//  "userSettings": [
//    {
//      "user": "USERNAME_1",
//      "settings": {
//        "ИМЯ_ПЕРЕМЕННОЙ_1": "ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_1",
//        "ИМЯ_ПЕРЕМЕННОЙ_2": "ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_2",
//      }
//    },
//    {
//      "user": "USERNAME_2",
//      "settings": {
//        "ИМЯ_ПЕРЕМЕННОЙ_1": "ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_1",
//        "ИМЯ_ПЕРЕМЕННОЙ_2": "ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_2",
//      }
//    }
//  ]
// }
//
// Параметры:
//  ПутьКФайлу - Строка - путь к каталогу, где находится файл с настройками 
//
&НаКлиенте
Процедура ЗагрузитьИзФайла(ПутьКаталогу = "") Экспорт
	
	ИмяФайлаНастроек = "user_settings.json";
	
	Если ПустаяСтрока(ПутьКаталогу) Тогда
		ПутьКФайлу = КонтекстЯдра.ПреобразоватьПутьСТочкамиКНормальномуПути("$workspaceRoot\" + ИмяФайлаНастроек);
		
		ПутьКФайлу = ?(КонтекстЯдра.ФайлСуществуетКомандаСистемы(ПутьКФайлу), ПутьКФайлу, 
			КонтекстЯдра.ПреобразоватьПутьСТочкамиКНормальномуПути("$instrumentsRoot\" + ИмяФайлаНастроек));
			
		ПутьКФайлу = ?(КонтекстЯдра.ФайлСуществуетКомандаСистемы(ПутьКФайлу), ПутьКФайлу, 
			КаталогРепозитория() + "\" + ИмяФайлаНастроек);
	Иначе
		ПутьКФайлу = ПутьКаталогу + "\" + "user_settings.json";
	КонецЕсли;
	
	Если Не КонтекстЯдра.ФайлСуществуетКомандаСистемы(ПутьКФайлу) Тогда
		Возврат;
	КонецЕсли;
	
	ТекЮзер = ТекущийПользовательОС();
	
	ЧтениеПеременных = Вычислить("Новый ЧтениеJSON()");
	ЧтениеПеременных.ОткрытьФайл(ПутьКФайлу);
	ГлобальныеПеременные = Вычислить("ПрочитатьJSON(ЧтениеПеременных, Истина)");
	ЧтениеПеременных.Закрыть();
	
	МассивНастроек = ГлобальныеПеременные["userSettings"];
	
	НастройкиЮзераНайдены = Ложь;
	Для каждого СтрокаПользователя Из МассивНастроек Цикл
		Если ВРег(СтрокаПользователя["user"]) = ВРег(ТекЮзер) Тогда 
			НастройкиЮзераНайдены = Истина;
			СтрокаНастроек = СтрокаПользователя["settings"];
			Для каждого ПеремЮзера Из СтрокаНастроек Цикл
				Попытка
					КонтекстЯдра.ОбъектКонтекстСохраняемый.Вставить(ПеремЮзера.Ключ, ПеремЮзера.Значение);
				Исключение
					//значит надо сохранить значение не в структуру а в соответствие
					КонтекстЯдра.СохранитьЗначениеВКонтекстСохраняемый(ПеремЮзера.Ключ, ПеремЮзера.Значение);
				КонецПопытки;
			КонецЦикла;
			ВывестиЗагруженныеНастройкиВЖР(СтрокаНастроек);
		КонецЕсли;
	КонецЦикла;
	
	Если Не НастройкиЮзераНайдены Тогда
		ТекстСообщения = КонтекстЯдра.ПолучитьТекстСообщенияПользователю(
			НСтр("ru = 'Ошибка. Не найдены настройки пользователя %1 в файле %2'"));
		ТекстСообщения = СтрЗаменить(ТекстСообщения,"%1", ТекЮзер);
		ТекстСообщения = СтрЗаменить(ТекстСообщения,"%2", ПутьКФайлу);
		КонтекстЯдра.СделатьСообщение(ТекстСообщения);
	КонецЕсли;
	
КонецПроцедуры

// } API

// { Helpers

&НаСервере
Функция ЭтотОбъектНаСервере()
	Возврат РеквизитФормыВЗначение("Объект");
КонецФункции

&НаКлиенте
Функция ТекущийПользовательОС()
	
	СисИнфо = Новый СистемнаяИнформация;
	
	Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86
		Или СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
	
		ПользовательОС = "";
		Попытка
			NetWork = Новый COMObject("wscript.network");
			ПользовательОС = NetWork.Username; 
		Исключение
			Shell = Новый COMОбъект("WScript.Shell");
			ПапкаПользователя = Shell.ExpandEnvironmentStrings("%UserProfile%");
			ИндексРазделителя = СтрНайти(ПапкаПользователя, "\", НаправлениеПоиска.СКонца);
			ПользовательОС = Прав(ПапкаПользователя, СтрДлина(ПапкаПользователя) - ИндексРазделителя);
		КонецПопытки;
		
	Иначе
		Сообщить(НСтр("ru = 'Функция ТекущийПользовательОС() реализована только для Windows'; 
			|en = 'Function for getting current username is implemented only for windows'"));
	КонецЕсли;
	
	Возврат ПользовательОС;
	
КонецФункции

&НаСервереБезКонтекста
Процедура ВывестиЗагруженныеНастройкиВЖР(знач НастройкиПользователя)
	
	НастройкиСтрокой = "";
	
	Для каждого СтрокаФайла Из НастройкиПользователя Цикл
		НастройкиСтрокой = НастройкиСтрокой + Символы.ПС + СтрокаФайла.Ключ + " " + СтрокаФайла.Значение;
	КонецЦикла;
	
	ЗаписьЖурналаРегистрации("VanessaBehavior.ЗагрузкаГлобальныхПеременных", 
		УровеньЖурналаРегистрации.Информация, , ,
		НСтр("ru = 'Загружены глобальные переменные'") + НастройкиСтрокой);
	
КонецПроцедуры

&НаКлиенте
Функция КаталогРепозитория()
	
	СтрокаКоманды = "CD """ + КонтекстЯдра.ИспользуемоеИмяФайла + """
		|git rev-parse --show-superproject-working-tree"; // если add используется как сабмодуль
	
	КонсольныйВывод = "";
	ВыполнитьКомандуОСБезПоказаЧерногоОкнаСВыводом(СтрокаКоманды,,, КонсольныйВывод);
	КорневойПутьПроекта = СокрЛП(СтрПолучитьСтроку(КонсольныйВывод, СтрЧислоСтрок(КонсольныйВывод)));
	
	Если Не КонтекстЯдра.ФайлСуществуетКомандаСистемы(КорневойПутьПроекта) Тогда
		СтрокаКоманды = "CD """ + КонтекстЯдра.ИспользуемоеИмяФайла + """
			|git rev-parse --show-toplevel"; // если add используется просто является вложенным каталогом
		
		ВыполнитьКомандуОСБезПоказаЧерногоОкнаСВыводом(СтрокаКоманды,,, КонсольныйВывод);
		КорневойПутьПроекта = СокрЛП(СтрПолучитьСтроку(КонсольныйВывод, СтрЧислоСтрок(КонсольныйВывод)));
	КонецЕсли;
	
	Возврат КорневойПутьПроекта;
	
КонецФункции

&НаКлиенте
Функция ВыполнитьКомандуОСБезПоказаЧерногоОкнаСВыводом(Знач ТекстКоманды, Знач ЖдатьОкончания = Истина, 
	Знач ИспользоватьКодировкуТекстаUTF8 = Истина, КонсольныйВывод = "") Экспорт
	
	Если ЖдатьОкончания = -1 Тогда
		ЖдатьОкончания = Истина;
	ИначеЕсли ЖдатьОкончания = 0 Тогда
		ЖдатьОкончания = Ложь;
	КонецЕсли;

	УдалятьФайл = Ложь;
	ИмяВременногоФайлаКоманды = ТекстКоманды;
	Если ИспользоватьКодировкуТекстаUTF8 Тогда
		
		ИмяВременногоФайлаКоманды = ПолучитьИмяВременногоФайла("bat");
		
		//эти строки нужны для записи файла без BOM
		ЗТ = Новый ЗаписьТекста(ИмяВременногоФайлаКоманды, "CESU-8", , Ложь);
		ЗТ.ЗаписатьСтроку("chcp 65001");
	
		ЗТ.ЗаписатьСтроку(ТекстКоманды);
		ЗТ.Закрыть();
		
		УдалятьФайл = Истина;
	КонецЕсли;
	
	ИмяФайлаВывода = ПолучитьИмяВременногоФайла("txt");
	ИмяВременногоФайлаКоманды = "cmd /c """ + ИмяВременногоФайлаКоманды + " -c ... > """ + ИмяФайлаВывода + """";

	КонтекстЯдра.Отладка(ТекстКоманды);
	//КонтекстЯдра.Отладка(ИмяВременногоФайлаКоманды);

	WshShell = Новый COMОбъект("WScript.Shell");

	Рез = WshShell.Run(ИмяВременногоФайлаКоманды, 0, ?(ЖдатьОкончания, -1, 0));
	Если Рез = 0 Тогда
		// команда выполнилась успешно
		ЧТ = Новый ЧтениеТекста(ИмяФайлаВывода);
		КонсольныйВывод = ЧТ.Прочитать();
	КонецЕсли;
	
	Если ЖдатьОкончания И УдалятьФайл Тогда
		//иначе удалять нельзя
		Если КонтекстЯдра.ЕстьПоддержкаАсинхронныхВызовов Тогда
			// для скорости не удаляем временный файл, сервер потом удалит КонтекстЯдра.УдалитьФайлыКомандаСистемы(ИмяВременногоФайлаКоманды);
		Иначе
			УдалитьФайлы(ИмяВременногоФайлаКоманды);
		КонецЕсли;
	КонецЕсли;

	Возврат Рез;
КонецФункции

// } Helpers
